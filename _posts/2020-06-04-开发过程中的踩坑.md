# 项目 踩坑

## Vue 使用踩坑

> 主要针对 Vue2.0

### 关于组件的重新绘制和复用

我们都知道在使用数组或对象，对某些组件进行循环渲染时，Vue 会 warn 提示尽量写`key`，为啥呢，就是因为在重新渲染`DOM`的时候，会根据`key`来决定是否重新绘制一个新的组件；所以我们在动态增删被渲染的数组（对象）元素时，应该尽量保证已有节点的`key`是不变的，这样就不会触发旧节点的重新渲染，在保证渲染效率的同时，完成某些业务场景。

## ES6 相关

### async/await

遇到个使用上的问题，当 `await` 后面跟了个非 `promise` 对象时，就容易出问题，看下面的例子：

```javascript
const f = async () => {
  // otherFunc返回的不是promise对象
  let tmp = await otherFunc();
  tmp;
  // Promise{status}
};
```

其实代码本意是拿到`otherFunc`的返回值做下一步操作，但是如果返回值本身不是`thenable`对象，这样拿到的值就是一个`Promise`了，所以尽量就别在不是异步函数的函数前加`await`关键字了。

## ant-design-vue 框架踩坑

### form 相关

- `validator`这傻逼函数在方法内部不会报错；从而导致整个表单的`validate`失效，常见的问题有，内置校验器只会在`console`报错，不会在`view`层面体现，因为函数运行卡在了`validator`方法中，不会抛出异常（目前在 issue 里面看到的原因是因为校验函数必须调用`callback`方法，并且会一直等待`callback`方法被调用，如果内部报错了，很明显`callback`就不会正常被调用，导致校验器失效）

### a-tree 相关

原生的树结构，需要注意一个坑；如果`checkStrictly === true`，会把子节点和祖先节点关联起来，通俗点说就是选择祖先节点了，它的子节点也会级联被选中，如果选择了子节点，会级联半选中祖先节点；第二种情况就会出现问题了，因为组件没有提供`halfChecked`，所以要自己手动定义个变量来保存这个半选中的值；有些时候这个半选中的值是有用的。像下面这张图中，其实节点`0-0, 0-0-1`是半选中状态的，但是没有提供`props`来获取，接着往下看；

![关联树实例](./img/in-post/antdv-trap/tree-sample.png)

- 怎么保存半选中状态的值？考虑到从子节点的选中状态，反过来找父节点去判断是不是半选中，其实尝试了下太麻烦了，所以就用原生的事件来做了；

  - 监听`@check`，参数包括`checkedKeys, e:{checked: bool, checkedNodes, node, event}`，全选中的状态直接取第一个参数`checkedKeys`就行，是个数组；半选中状态在参数`e.halfCheckedKeys`中保存，也是个数组，你甚至在文档里都找不到这个数组。

  - 这样就会衍生出另一个问题，在设置`defaultCheckedKeys`时，只能设置全选中的节点，半选中的状态是自动生成的；但是如果不触发`@check`事件，就肯定得不到半选中的节点集合，所以其实建议是第一次保存`checkedKeys`时，把`halfCheckedKeys`也存储下来
