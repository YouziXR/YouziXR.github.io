xx = Reflect

## Reflect 语法及使用

·Reflect·是 ES6 中用来操作对象的 API；

在 ES6 之前我们只能使用·Object.method·来访问原生对象的内部方法，ES6 语法将大部分内部方法加到了·xx·上，所以我们现在可以使用·xx.defineProperty·这样的形式来调用内部方法；

这个方法还修改了一些内部方法的返回值，使用·Object.defineProperty·来定义一个无法配置的属性时，会抛出错误，而调用·xx.defineProperty·会返回·false·；

ES5 使用·in | delete·保留字来判断或者删除属性，这样的写法很 JS 但很不 OO，过于命令式，在 ES6 后可以使用·xx.has | xx.deleteProperty·来实现，这很`coooooooool`；

·xx·对象的方法可以在·Proxy·对象的方法中使用，·Proxy·对象总共有 13 种代理方法，在·xx·中都有对应的方法；我们在代理方法中可以直接调用·xx.method·来调用默认的原生对象方法，完成默认的对象操作，再添加自己的操作；

> 当·Proxy·和·Reflect·对象一起使用时，为了避免重复递归触发当前代理方法，调用·Reflect·方法不会再触发当前的方法；比如在·handler·里设置了·set·代理，那在·set·代理中再调用·Reflect.set·方法不会再次触发代理的·set·方法；

由于·xx·和·Proxy·对象的方法都一样的，参数也差不多，这里就不介绍太多，罗列一下方法名和参数即可；

```javascript
Reflect.get(target, name, receiver);
Reflect.set(target, name, value, receiver);
Reflect.has(target, name);
Reflect.apply(target, thisArg, args);
Reflect.ownKeys(target);
Reflect.construct(target, args);
Reflect.isExtensible(target);
Reflect.defineProperty(target, name, desc);
Reflect.deleteProperty(target, name);
Reflect.getPrototypeOf(target);
Reflect.setPrototypeOf(target, prototype);
Reflect.preventExtensions(target);
Reflect.getOwnPropertyDescriptor(target, name);
```

> 参数中·target·必须是一个对象，否则会直接报错；·receiver·表示，当读取的属性部署了·get | set·函数，函数的·this·绑定到·receiver·；

### 实例

#### Reflect.get(target, name, receiver)

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  }
};
var myReceiverObject = {
  foo: 4,
  bar: 4
};
Reflect.get(myObject, 'baz', myReceiverObject); // 8

let p = new Proxy(
  {},
  {
    get(t, k, r) {
      console.log(t, k, r);
      return Reflect.get(t, k, r) + 1;
    }
  }
);
```

从上述代码可以看出，在·get·函数中，·this·被改写成·myReceiverObject·了，这就是第三个参数的作用了；

#### Reflect.set(target, name, value, receiver)

和·get·方法类似，多传入了指定的属性值；当和·Proxy·对象一起使用时，在·Proxy·方法内部使用了·set·方法并传入了第四个参数·receiver·，会额外触发·Proxy.defineProperty·方法，看一个例子；

```javascript
let o = {};
let p = new Proxy(o, {
  set(t, k, v, r) {
    console.log('set');
    return Reflect.set(t, k, v, r);
  },
  defineProperty(t, k, p) {
    console.log('define');
  }
});
p.a = 10;
// set
// define
```

这是因为传入了·receiver·参数改变了·set·函数内部·this·的指向，上述代码指向了·Proxy·实例·p·，所以其实是在给实例·p·做定义属性操作，此时就会触发·defineProperty·的代理；如果不传入第四个参数，这时就是直接对第一个参数·target·指向的·o·对象操作了，就不会触发代理了；

#### Reflect.has(obj, name)

该方法对应 ES5 的·in·运算符，在·Proxy·那篇也提到过，·in·运算符不区分是否是在原型上的属性，这个方法也一样，我们可以用这个方法来判断属性是否存在对象上（不论是在对象本身还是在对象的原型上）；

```javascript
let o = {
  a: 1
};
let p = Object.create(o);
p.b = 2;
// ES5
'a' in p;
'b' in p;
// ES6
Reflect.has(p, 'a');
Reflect.has(p, 'b');
```

#### Reflect.deleteProperty(obj, name)

用于删除对象的方法；返回布尔值，删除成功或要删除的属性不存在，都返回·true·；删除失败，属性依然存在返回·false·；

```javascript
let o = { a: 1 };
// ES5
delete o.a;
// ES6
Reflect.deleteProperty(o, 'a');
```

#### Reflect.construct(target, args)

等同于·new Class()·，是创建构造函数的方法；

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}
// ES5
let p = new Person('steven', 24);
// ES6
let q = Reflect.construct(Person, ['stevent', 24]);
```

#### Reflect.getPrototypeOf(obj)

用于读取对象的`__proto__`属性，对应·Object.getPrototypeof·方法；毕竟浏览器环境才有可能配置对象的原型属性；另外用·Object.getPrototypeof·方法会将参数转化成对象，但是·Reflect.getPrototypeOf·不会强制转换，会先进行类型检测，非对象类型直接抛出异常。

#### Reflect.setPrototypeOf(obj, newProto)

用于设置原型，返回布尔值，表示是否设置成功；如果无法设置目标对象的原型，就会返回`false`；

#### Reflect.apply(func, thisArg, args)

用于绑定·this·对象后执行第一个给定的参数；我们平常使用·apply | call·方法来绑定函数的·this·，现在我们可以使用这个方法来替代了;一个比较直观的例子：

```javascript
let a = [1, 2, 3];
// ES5
let min = Math.min.apply(Math, a);
let max = Math.max.apply(Math, a);
let type = Object.prototype.toString.call(a);
// ES6
let min1 = Reflect.apply(Math.min, null, a);
let type1 = Reflect.apply(Object.prototype.toString, a, []);
```

那按照 ES6 的写法，我们可以封装一个·APPLY·函数，用于改变函数内部·this·值并执行；

```javascript
function APPLY(method, _this, ...args) {
  return Reflect.apply(method, _this, args);
}
```

#### Reflect.defineProperty(target, propertyKey, attributes)

用来显式定义对象属性，等同于·Object.defineProperty·；

与·Proxy.defineProperty·方法共用，例子：

```javascript
let p = new Proxy(
  {},
  {
    defineProperty(t, k, d) {
      console.log(t, k, d);
      return Reflect.defineProperty(t, k, d);
    }
  }
);
p.a = 10;
// {} "a" {value: 10, writable: true, enumerable: true, configurable: true}
p.a;
// 10
```

#### Reflect.getOwnPropertyDescriptor(target, propertyKey)

用于获取对象属性的描述对象；几乎和·Object.getOwnPropertyDescriptor·功能一致，除了·Reflect·会先检测第一个参数的类型外；

#### Reflect.isExtensible(target)

用于判断对象是否可扩展；返回布尔值；和·Object.isExtensible·功能一致；

#### Reflect.preventExtensions(target)

用于让一个对象变为不可扩展的对象；返回布尔值，表示是否操作成功；与·Object.preventExtensions·功能一致；

#### Reflect.ownKeys(target)

用于返回对象自身所有属性，包括属性名是·Symbol·类型的，不包括原型上的属性；基本等同于·Object.getOwnPropertyNames + Object.getOwnPropertySymbols·的并集；

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  [Symbol.for('baz')]: 3,
  [Symbol.for('bing')]: 4
};

// 旧写法
Object.getOwnPropertyNames(myObject);
// ['foo', 'bar']

Object.getOwnPropertySymbols(myObject);
//[Symbol(baz), Symbol(bing)]

// 新写法
Reflect.ownKeys(myObject);
// ['foo', 'bar', Symbol(baz), Symbol(bing)]
```
